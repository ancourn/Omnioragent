import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs/promises';
import path from 'path';
import { execSync } from 'child_process';

// Define types for our pipeline
interface PipelineTask {
  id: string;
  description: string;
  type: string;
}

interface Plan {
  title: string;
  tasks: PipelineTask[];
  acceptance_criteria: string[];
  risks: string[];
  time_budget_minutes: number;
}

interface Specification {
  openapi: any;
  db_schema: any;
  folder_tree: string[];
  tests: string[];
}

interface LogEntry {
  time: string;
  step: string;
  status: string;
  note: string;
}

// Root directory
const ROOT = process.cwd();
const WORKSPACE = path.join(ROOT, 'workspace');
const TEMPLATES = path.join(ROOT, 'templates', 'webapp_fastapi_postgres_react');

async function logStep(runPath: string, step: string, status: string, note: string = "") {
  const entry: LogEntry = {
    time: new Date().toISOString() + "Z",
    step,
    status,
    note
  };
  
  const logFile = path.join(runPath, 'pipeline_log.json');
  
  try {
    let data: LogEntry[] = [];
    try {
      const existingData = await fs.readFile(logFile, 'utf-8');
      data = JSON.parse(existingData);
    } catch (error) {
      // File doesn't exist yet, start with empty array
    }
    
    data.push(entry);
    await fs.writeFile(logFile, JSON.stringify(data, null, 2));
  } catch (error) {
    console.error('Error writing log:', error);
  }
}

function planner(nlGoal: string): Plan {
  const tasks: PipelineTask[] = [
    {"id":"spec-1","description":"Produce OpenAPI and DB schema","type":"spec"},
    {"id":"code-1","description":"Copy template and adapt config","type":"code"},
    {"id":"test-1","description":"Run unit tests (simulated)","type":"test"},
    {"id":"deploy-1","description":"Build docker-compose (simulated)","type":"deploy"},
    {"id":"eval-1","description":"Evaluate acceptance criteria","type":"eval"},
  ];
  
  return {
    title: "AutoRun MVP",
    tasks,
    acceptance_criteria: ["/health returns 200", "CI tests pass"],
    risks: ["DB not ready"],
    time_budget_minutes: 60
  };
}

function specifier(plan: Plan): Specification {
  const openapi = {
    paths: {
      "/health": {"get": {"responses": {"200": {"description": "OK"}}}},
      "/auth/signup": {"post": {"requestBody": {"content": {"application/json": {}}}, "responses": {"200": {}}}},
      "/todos": {"get": {}, "post": {}}
    }
  };
  
  const db_schema = {
    tables: [
      {"name": "users", "columns": [{"name": "id", "type": "integer"}, {"name": "email", "type": "text"}]},
      {"name": "todos", "columns": [{"name": "id", "type": "integer"}, {"name": "title", "type": "text"}]}
    ]
  };
  
  return {
    openapi,
    db_schema,
    folder_tree: ["backend/", "frontend/"],
    tests: ["test_health.py"]
  };
}

async function coder(spec: Specification, runPath: string): Promise<boolean> {
  try {
    const src = TEMPLATES;
    const dst = path.join(runPath, 'repo');
    
    // Check if templates exist, if not create a basic structure
    try {
      await fs.access(src);
    } catch {
      // Create basic template structure if it doesn't exist
      await fs.mkdir(path.join(dst, 'backend'), { recursive: true });
      await fs.mkdir(path.join(dst, 'frontend'), { recursive: true });
      
      // Create basic backend files
      await fs.writeFile(
        path.join(dst, 'backend', 'app', 'main.py'),
        'from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/health")\ndef health():\n    return {"status": "ok"}\n'
      );
      
      // Create basic docker-compose
      await fs.writeFile(
        path.join(dst, 'docker-compose.yml'),
        'version: "3.8"\nservices:\n  app:\n    build: ./backend\n    ports:\n      - "8000:8000"\n'
      );
      
      // Create README
      await fs.writeFile(
        path.join(dst, 'README.md'),
        '# Generated Web App\n\nThis is a generated web application.\n'
      );
    }
    
    // Copy template files if they exist
    if (await fs.stat(src).catch(() => null)) {
      await fs.cp(src, dst, { recursive: true });
    }
    
    // Update README with timestamp
    const readmePath = path.join(dst, 'README.md');
    try {
      const readmeContent = await fs.readFile(readmePath, 'utf-8');
      const updatedContent = `Run generated by Omnior Orchestrator at ${new Date().toISOString()}Z\n\n${readmeContent}`;
      await fs.writeFile(readmePath, updatedContent);
    } catch (error) {
      // README might not exist, that's ok
    }
    
    // Save spec
    await fs.writeFile(path.join(dst, 'SPEC.json'), JSON.stringify(spec, null, 2));
    
    return true;
  } catch (error) {
    console.error('Coder error:', error);
    return false;
  }
}

async function tester(runPath: string): Promise<[boolean, string]> {
  const repo = path.join(runPath, 'repo');
  try {
    const backendExists = await fs.access(path.join(repo, 'backend', 'app', 'main.py')).then(() => true).catch(() => false);
    
    // Simulate test execution time
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    if (backendExists) {
      return [true, "Simulated tests passed"];
    } else {
      return [false, "Tests failed: missing files"];
    }
  } catch (error) {
    return [false, "Tests failed: error checking files"];
  }
}

async function fixer(runPath: string, testOk: boolean): Promise<[boolean, string]> {
  if (testOk) {
    return [true, "No fixes needed"];
  } else {
    return [false, "Automatic fixes not available in stub orchestrator"];
  }
}

async function deployer(runPath: string): Promise<[boolean, string]> {
  const repo = path.join(runPath, 'repo');
  try {
    const dockerComposeExists = await fs.access(path.join(repo, 'docker-compose.yml')).then(() => true).catch(() => false);
    
    if (dockerComposeExists) {
      return [true, "docker-compose found"];
    } else {
      return [false, "docker-compose missing"];
    }
  } catch (error) {
    return [false, "Error checking docker-compose"];
  }
}

function evaluator(runPath: string, testOk: boolean, deployOk: any) {
  const accept = testOk && deployOk;
  const issues: string[] = [];
  
  if (!testOk) issues.push("tests_failed");
  if (!deployOk) issues.push("deploy_config_missing");
  
  return {
    accepted: accept,
    issues
  };
}

async function runPipeline(nlGoal: string): Promise<string> {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -1) + 'Z';
  const runPath = path.join(WORKSPACE, `run-${timestamp}`);
  
  await fs.mkdir(runPath, { recursive: true });
  
  await logStep(runPath, "start", "ok", nlGoal);
  
  const plan = planner(nlGoal);
  await logStep(runPath, "planner", "ok", JSON.stringify(plan));
  
  const spec = specifier(plan);
  await fs.writeFile(path.join(runPath, 'SPECIFIER.json'), JSON.stringify(spec, null, 2));
  await logStep(runPath, "specifier", "ok", "spec saved");
  
  try {
    const coderSuccess = await coder(spec, runPath);
    await logStep(runPath, "coder", "ok", "repo created");
  } catch (error: any) {
    await logStep(runPath, "coder", "fail", error.message);
    return runPath;
  }
  
  const [testOk, testNote] = await tester(runPath);
  await logStep(runPath, "tester", testOk ? "ok" : "fail", testNote);
  
  const [fixOk, fixNote] = await fixer(runPath, testOk);
  await logStep(runPath, "fixer", fixOk ? "ok" : "fail", fixNote);
  
  const [deployOk, deployNote] = await deployer(runPath);
  await logStep(runPath, "deployer", deployOk ? "ok" : "fail", deployNote);
  
  const evalRes = evaluator(runPath, testOk, deployOk);
  await fs.writeFile(path.join(runPath, 'EVALUATION.json'), JSON.stringify(evalRes, null, 2));
  await logStep(runPath, "evaluator", "ok", JSON.stringify(evalRes));
  
  await logStep(runPath, "finish", "ok", "pipeline complete");
  
  return runPath;
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { goal } = body;
    
    if (!goal) {
      return NextResponse.json({ error: 'Goal is required' }, { status: 400 });
    }
    
    const runPath = await runPipeline(goal);
    
    return NextResponse.json({ 
      success: true, 
      runPath,
      message: `Pipeline completed. Artifacts written to: ${runPath}`
    });
  } catch (error: any) {
    console.error('Pipeline error:', error);
    return NextResponse.json({ 
      error: 'Pipeline failed', 
      details: error.message 
    }, { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({ 
    message: 'Omnior Orchestrator API is running',
    endpoints: {
      'POST /api/orchestrator': 'Run pipeline with natural language goal',
      'GET /api/orchestrator': 'API status'
    }
  });
}